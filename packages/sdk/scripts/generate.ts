#!/usr/bin/env node

/**
 * ModelKit Type Generator
 * Fetches features from your ModelKit API and generates TypeScript types
 */

import * as fs from "fs";
import * as path from "path";

interface Feature {
  featureId: string;
  override: {
    modelId: string;
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    topK?: number;
    updatedAt?: number;
  };
}

async function fetchFeatures(apiUrl: string): Promise<Feature[]> {
  try {
    const response = await fetch(`${apiUrl}/overrides`);

    if (!response.ok) {
      throw new Error(`API returned ${response.status}: ${response.statusText}`);
    }

    const data = (await response.json()) as { overrides?: Feature[] };

    if (!data || !Array.isArray(data.overrides)) {
      throw new Error("Invalid API response format");
    }

    return data.overrides;
  } catch (error) {
    throw new Error(
      `Failed to fetch features: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

function generateTypeFile(features: Feature[]): string {
  if (features.length === 0) {
    return `/**
 * ModelKit Feature IDs
 * Auto-generated by ModelKit
 *
 * No features found.
 * Make sure your ModelKit instance has features configured.
 */

export type FeatureId = string;
`;
  }

  const sortedIds = features.map((f) => f.featureId).sort();
  const typeUnion = sortedIds.map((id) => `  | "${id}"`).join("\n");

  const exampleIds = sortedIds.slice(0, 3);
  const exampleFeatures = features
    .filter((f) => exampleIds.includes(f.featureId))
    .slice(0, 3);

  const example1 = exampleFeatures[0];
  const example2 = exampleFeatures[1];
  const example3 = exampleFeatures[2];

  return `/**
 * ModelKit Feature IDs
 * Auto-generated by ModelKit
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Run \`npx modelkit-generate --api-url <url>\` to regenerate
 *
 * Found ${features.length} feature${features.length === 1 ? "" : "s"}
 */

export type FeatureId =
${typeUnion};

/**
 * ========================================
 * USAGE EXAMPLES (Based on your features)
 * ========================================
 */

// 1. Setup ModelKit with type-safe feature IDs
import type { FeatureId } from "./modelkit.generated";
import { createModelKit, createRedisAdapter } from "@benrobo/modelkit";

const adapter = createRedisAdapter<FeatureId>({
  url: process.env.REDIS_URL || "redis://localhost:6379"
});

const modelKit = createModelKit<FeatureId>(adapter, {
  cacheTTL: 60000, // 1 minute cache
  debug: false
});

// 2. Get model with runtime override support
${example1 ? `// Feature: ${example1.featureId}
// Current model: ${example1.override.modelId}
const model1 = await modelKit.getModel(
  "${example1.featureId}",
  "anthropic/claude-3.5-sonnet" // fallback if no override
);
// Returns: "${example1.override.modelId}" (current override)
` : ''}
${example2 ? `
// Feature: ${example2.featureId}
const model2 = await modelKit.getModel(
  "${example2.featureId}",
  "anthropic/claude-3.5-sonnet"
);
// Returns: "${example2.override.modelId}"
` : ''}
${example3 ? `
// Feature: ${example3.featureId}
const model3 = await modelKit.getModel(
  "${example3.featureId}",
  "anthropic/claude-3.5-sonnet"
);
// Returns: "${example3.override.modelId}"
` : ''}
// 3. Set runtime overrides (zero-downtime configuration changes)
await modelKit.setOverride("${exampleIds[0]}", {
  modelId: "anthropic/claude-opus-4",
  temperature: 0.9,
  maxTokens: 4096,
  topP: 1.0,
  topK: 0
});

// 4. Get full configuration
const config = await modelKit.getConfig("${exampleIds[0]}");
// Returns: { modelId, temperature?, maxTokens?, topP?, topK?, updatedAt? } | null

// 5. Clear override (revert to fallback)
await modelKit.clearOverride("${exampleIds[0]}");

// 6. List all active overrides
const overrides = await modelKit.listOverrides();
// Returns: Array<{ featureId: FeatureId; override: ModelOverride }>

/**
 * ========================================
 * TYPE SAFETY IN ACTION
 * ========================================
 */

// ‚úÖ TypeScript autocomplete works!
await modelKit.getModel("${exampleIds[0]}", "anthropic/claude-3.5-sonnet");

// ‚ùå Compile-time error for invalid feature IDs
// await modelKit.getModel("invalid.feature", "gpt-4");
// Error: Argument of type '"invalid.feature"' is not assignable to parameter of type 'FeatureId'

/**
 * ========================================
 * YOUR FEATURES (${features.length} total)
 * ========================================
 *
${features.map((f) => ` * ‚Ä¢ ${f.featureId} ‚Üí ${f.override.modelId}`).join('\n')}
 */
`;
}

async function main() {
  const args = process.argv.slice(2);

  // Parse arguments
  let apiUrl = "";
  let outputPath = "src/modelkit.generated.ts";

  for (let i = 0; i < args.length; i++) {
    if (args[i] === "--api-url" && args[i + 1]) {
      apiUrl = args[i + 1];
      i++;
    } else if (args[i] === "--output" && args[i + 1]) {
      outputPath = args[i + 1];
      i++;
    } else if (args[i] === "--help" || args[i] === "-h") {
      console.log(`
ModelKit Type Generator

Usage:
  npx modelkit-generate --api-url <url> [options]

Options:
  --api-url <url>      ModelKit API endpoint URL (required)
  --output <path>      Output file path (default: src/modelkit.generated.ts)
  --help, -h           Show this help message

Example:
  npx modelkit-generate --api-url http://localhost:3000/api/modelkit
      `);
      process.exit(0);
    }
  }

  if (!apiUrl) {
    console.error("‚ùå Error: --api-url is required\n");
    console.log("Usage: npx modelkit-generate --api-url <url>");
    console.log("Example: npx modelkit-generate --api-url http://localhost:3000/api/modelkit");
    process.exit(1);
  }

  try {
    console.log("üîç Fetching features from ModelKit API...\n");
    console.log(`   API URL: ${apiUrl}\n`);

    const features = await fetchFeatures(apiUrl);

    if (features.length === 0) {
      console.log("‚ö†Ô∏è  No features found");
      console.log("   Make sure your ModelKit instance has features configured\n");
    } else {
      console.log(`‚úÖ Found ${features.length} feature${features.length === 1 ? "" : "s"}:\n`);
      features.slice(0, 5).forEach((f) => {
        console.log(`   ‚Ä¢ ${f.featureId} ‚Üí ${f.override.modelId}`);
      });
      if (features.length > 5) {
        console.log(`   ... and ${features.length - 5} more`);
      }
      console.log();
    }

    const content = generateTypeFile(features);
    const outputDir = path.dirname(outputPath);

    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    fs.writeFileSync(outputPath, content);
    console.log(`‚úÖ Generated types at ${outputPath}`);
    console.log(`\nüí° Import with: import type { FeatureId } from "./${path.basename(outputPath).replace(/\.ts$/, "")}";`);
  } catch (error) {
    console.error("‚ùå Error:", error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

main();
